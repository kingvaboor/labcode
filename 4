PHASE 1

#include<iostream>
#include<vector>
#include<fstream>
using namespace std;

struct OS{

    vector<vector<char>> memory;
    ifstream inputfile;
    fstream outputfile;
    string buffer;
    int IC;
    int SI;
    vector<char> IR;
    vector<char> R;
    bool C;

    OS() : memory(100,vector<char>(4,' ')), IC(0), IR(4), R(4), C(false), inputfile("input.txt") {}
    void load();        // read the input file
    void init();
    void startExecution();
    void executeUserProgram();
    void READ(int);
    void WRITE(int);
};

void OS :: init(){

    for(int i = 0; i < 100; i++){
        for(int j = 0; j < 4; j++){
            memory[i][j] = ' ';
        }
    }

    for(int i = 0; i < 4; i++){
        IR[i] = ' ';
        R[i] = ' ';
    }

    C = false;
    IC = 0;
    buffer.clear();
    data_card.clear();
}

void OS :: startExecution(){
    IC = 0;
    executeUserProgram();
    outputfile.open("output.txt",ios::app);
    outputfile << endl;
}

void OS :: READ(int SI){
    //cout << "reading..\n";

    int memoryaddr = (IR[2] - 48)*10 + (IR[3] - 48);
    int wordoffset = 0;
    int byteswritten = 0;

    getline(inputfile, buffer);

    for(int i = 0; i < 40; i++){
        if(i >= buffer.size()){
            memory[memoryaddr][wordoffset] = ' ';
            byteswritten++;
        }
        else{
            memory[memoryaddr][wordoffset] = buffer[i];
            byteswritten++;
        }

        if(byteswritten % 4 == 0){
            byteswritten = 0;
            wordoffset = 0;
            memoryaddr++;
        }
        else{
            wordoffset++;
        }
    }
}

void OS :: WRITE(int SI){

    outputfile.open("ouput.txt", ios::app);
    int memoryaddr = (IR[2] - 48)*10 + (IR[3] - 48);
    int wordoffset = 0;
    int byteswritten = 0;

    string str = "";

    for(int i = 0; i < 40; i++){
        outputfile << (memory[memoryaddr][wordoffset]);
        byteswritten++;
    
        if(byteswritten % 4 == 0){
            byteswritten = 0;
            wordoffset = 0;
            memoryaddr++;
        }
        else{
            wordoffset++;
        }
    } 
    outputfile << endl;
    outputfile.close();
}

void OS :: executeUserProgram(){
    
    while(true){

        for(int i = 0; i < 4; i++){
            IR[i] = memory[IC][i];
        }
        IC++;

        if(IR[0] == 'H')
            break;          // Terminate
        
        if(IR[0] == 'G' && IR[1] == 'D'){
            SI = 1;
            READ(SI);
        }
        else if(IR[0] == 'P' && IR[1] == 'D'){
            SI = 2;
            WRITE(SI);
        }
        else if(IR[0] == 'C' && IR[1] == 'R'){
            int memoryaddr = (IR[2] - 48)*10 + (IR[3] - 48);
            bool condition;
            for(int i = 0; i < 4; i++){
                
                if(memory[memoryaddr][i] != R[i]){
                    condition = true;
                    break;
                }
            }
            (condition ? (C = false) : (C = true));
        }

        else if(IR[0] == 'S' && IR[1] == 'R'){
            int memoryaddr = (IR[2] - 48)*10 + (IR[3] - 48);
            for(int i = 0; i < 4; i++){
               memory[memoryaddr][i] = R[i];                 
            }
        }

        else if(IR[0] == 'L' && IR[1] == 'R'){
            int memoryaddr = (IR[2] - 48)*10 + (IR[3] - 48);
            for(int i = 0; i < 4; i++){
                R[i] = memory[memoryaddr][i]; 
            }
        }

        else if(IR[0] == 'B' && IR[1] == 'T'){
            int memoryaddr = (IR[2] - 48)*10 + (IR[3] - 48);
            if(C)
                IC = memoryaddr;
        }
        else{
            break;
        }
    }
}

void OS :: load(){
    
    while(!inputfile.eof()){
        init();
        getline(inputfile, buffer);

        if(buffer.substr(0,4) == "$AMJ"){
            getline(inputfile, buffer);

            int memoryaddr = 0;
            int byteswritten = 0;
            int wordoffset = 0;
            //load code in memory
            while(buffer.substr(0,4) != "$DTA"){

                for(int i = 0; i < buffer.size(); i++){
                    if(buffer[i] == 'H'){
                        memory[memoryaddr][wordoffset] = buffer[i];
                        memoryaddr++;
                    }
                    else{
                        memory[memoryaddr][wordoffset] = buffer[i];
                        byteswritten++;   
                    }

                    if(byteswritten % 4 == 0){
                        wordoffset = 0;
                        memoryaddr++;
                        byteswritten = 0;
                    }
                    else{
                        wordoffset++;
                    }
                }
                getline(inputfile, buffer);
            }
            //program loaded in memory

            buffer.clear();
            startExecution();

            for(int i = 0; i < 100; i++){
                for(int j = 0; j < 4; j++){
                    cout << memory[i][j];
                }cout << endl;
            }
        }
    }
}

int main(){
    OS os;
    os.load();
}

$AMJ010200210001
GD30LR36SR40LR35SR41LR34SR42LR33SR43LR32 
SR44LR31SR45LR30SR46LR39SR47SR38SR49PD40 
H 
$DTA control card
AMA  PANANAL A CPLANN A A MA 
$END0102 
$AMJ020100120003
GD20LR20GD30CR33BT07GD40PD40PD20PD30GD40
PD40H
$DTA
HOPE FOR IT
THERE IS NO HOPE
BUT STILL HOPE
$END0201
$AMJ000300170007
GD20PD20GD30PD30GD40LR40SR20PD20PD30GD40
LR40SR20PD20PD30GD50PD50H
$DTA
3 LITTLE PIGS WENT TO OS CLASS.
THE WOLF ATE ONE!
2 LI
1 LI
CLASS DISMISSED!
$END0003
$AMJ020200160005
GD20PD20LR20SR30SR31PD30SR40SR41SR42PD40
SR50SR51PD50SR60PD60H
$DTA
*
$END0202
$AMJ000700200002
GD50LR50SR67LR51SR66LR52SR65LR53SR64LR54
SR63LR55SR62LR56SR61LR57SR60PD50PD60H
$DTA
   N   U   T   R   A   F   I   N
$END0007
$AMJ030100100003
GD20PD20GD30PD30LR20CR30BT10GD40PD40H
$DTA
VIT IS GOOD
VIIT IS GOOD
BOTH ARE SISTER INSTITUTES
$END0301
$AMJ030200080003
GD20PD20GD30PD30LR30SR20PD20H   
$DTA
CAT CAN EAT RAT
RAT CAN NOT EAT CAT
$END0302
$AMJ010100040001
GD20LR22SR25PD20H   
$DTA
I LIKE THIS PEN OF  
$END0101
$AMJ040100120004
GD20PD20GD30PD30GD40GD50LR20CR30BT10PD40
PD50H   
$DTA
ABCD
ABCD
DO NOT
MATCH
$END0401
$AMJ040200130004
GD20PD20GD30LR30SR20PD20GD40PD40GD50LR50
SR20PD20H   
$DTA
   RAT
   S
   ON
   M
$END0402
$AMJ010200070002
GD20LR26CR20BT06GD30PD30PD20H   
$DTA
RAM  IS OLDER THAN  SHRIRAM 
NOT IN EXISTANCE
$END0102
PHASE 2

#include<iostream>
#include<vector>
#include<fstream>
#include<unordered_set>
#include<algorithm>
using namespace std;

struct PCB{
    int TLL;
    int TLC;
    int TTL;
    int TTC;
};

struct OS{

    vector<vector<char>> memory;
    ifstream inputfile;
    fstream outputfile;
    string buffer;
    int IC;
    int SI;
    int PI;
    int EM;
    int TTL;
    int TLL;
    int PTBR;
    int prog_location;
    int cnt;
    int TI;
    vector<PCB> jobs;
    vector<char> IR;
    vector<char> R;
    vector<string> instruction_Set;
    bool C;
    unordered_set<int> alloc;

    OS() : memory(300 ,vector<char>(4,' ')), IC(0), IR(4), R(4), C(false), instruction_Set({"GD","PD","CR","SR","LR","BT"}),
    EM(0), PI(0), SI(0), inputfile("input.txt"), cnt(-1), jobs(10), TI(0) {}
    void load();        // read the input file
    void init();
    void startExecution();
    void executeUserProgram();
    void READ(int);
    void WRITE(int);
    int AddressMap(int,string);
    void endExecution(int,int);
};

void OS :: init(){

    for(int i = 0; i < 100; i++){
        for(int j = 0; j < 4; j++){
            memory[i][j] = ' ';
        }
    }

    for(int i = 0; i < 4; i++){
        IR[i] = ' ';
        R[i] = ' ';
    }

    C = false;
    prog_location = 0;
    PI = 0;
    SI = 0;
    EM = 0;
    IC = 0;
    cnt++;
    buffer.clear();
}

void OS :: startExecution(){
    IC = prog_location;
    executeUserProgram();
    outputfile.open("output.txt",ios::app);
    outputfile << endl;
    outputfile.close();
}

void OS :: READ(int realaddress){
    //cout << "reading..\n";
    int wordoffset = 0;
    int byteswritten = 0;

    getline(inputfile, buffer);

    if(buffer.substr(0,4) == "$END"){
        PI = 4;
        return;
    }

    for(int i = 0; i < 40; i++){
        if(i >= buffer.size()){
            memory[realaddress][wordoffset] = ' ';
            byteswritten++;
        }
        else{
            memory[realaddress][wordoffset] = buffer[i];
            byteswritten++;
        }

        if(byteswritten % 4 == 0){
            byteswritten = 0;
            wordoffset = 0;
            realaddress++;
        }
        else{
            wordoffset++;
        }
    }
}

void OS :: WRITE(int realaddress){

    outputfile.open("output.txt", ios::app);
    jobs[cnt].TLC++;
    
    int wordoffset = 0;
    int byteswritten = 0;

    for(int i = 0; i < 40; i++){
        outputfile << (memory[realaddress][wordoffset]);
        byteswritten++;
    
        if(byteswritten % 4 == 0){
            byteswritten = 0;
            wordoffset = 0;
            realaddress++;
        }
        else{
            wordoffset++;
        }
    } 
    outputfile << endl;
    outputfile.close();
}

void OS :: executeUserProgram(){
    
    while(true){
        for(int i = 0; i < 4; i++){
            IR[i] = memory[IC][i];
        }
        jobs[cnt].TTC++;

        if(IR[0] == 'H')
            break;          // Terminate

        string opcode = "";
        opcode += memory[IC][0];
        opcode += memory[IC][1];

        // Error handling-------------------------------------------------------------------------
            // Opcode error
            if(find(instruction_Set.begin(),instruction_Set.end(),opcode) == instruction_Set.end()){
                PI = 1;
                EM = 4;
                break;
            }

            //operand error
            if(isalpha(IR[2]) || isalpha(IR[3]) || IR[0] == '-' || isdigit(IR[1])){
                PI = 2;
                EM = 5;
                break;
            }

            if(PI == 4) {
                EM = 1;
                break;      // Out of Data error
            }
        //-------------------------------------------------------------------------------------

        //AddressTranslation-------------------------------------------------------------------

            int virtualmem = (IR[2] - 48)*10 + (IR[3] - 48);
            int realAddr = AddressMap(virtualmem, opcode);

            if(PI == 3) {
                EM = 6;
                break;      // Invalid page fault
            }

        //---------------------------------------------------------------------------------------
        
        if(IR[0] == 'G' && IR[1] == 'D'){
            SI = 1;
            READ(realAddr);
            jobs[cnt].TTC++;
        }
        else if(IR[0] == 'P' && IR[1] == 'D'){
            SI = 2;
            WRITE(realAddr);
        }
        else if(IR[0] == 'C' && IR[1] == 'R'){
            bool condition;
            for(int i = 0; i < 4; i++){
                
                if(memory[realAddr][i] != R[i]){
                    condition = true;
                    break;
                }
            }
            (condition ? (C = false) : (C = true));
        }

        else if(IR[0] == 'S' && IR[1] == 'R'){
            for(int i = 0; i < 4; i++){
               memory[realAddr][i] = R[i];                 
            }
            jobs[cnt].TTC++;
        }

        else if(IR[0] == 'L' && IR[1] == 'R'){
            for(int i = 0; i < 4; i++){
                R[i] = memory[realAddr][i]; 
            }
        }

        else if(IR[0] == 'B' && IR[1] == 'T'){
            int memoryaddr = (IR[2] - 48)*10 + (IR[3] - 48);
            if(C)
                IC = realAddr - 1;
        }
        else{
            break;
        }
        IC++;
    }
}

void OS :: load(){
    
    while(!inputfile.eof()){
        init();
        getline(inputfile, buffer);

        if(buffer.substr(0,4) == "$AMJ"){

            TTL = stoi(buffer.substr(8,4));
            TLL = stoi(buffer.substr(12,4));

            PCB card_job;
            card_job.TLC = 0;
            card_job.TTC = 0;
            card_job.TTL = TTL;
            card_job.TLL = TLL;
            jobs[cnt] = card_job;
            
            PTBR = rand() % 30;
            PTBR *= 10;

            // page table init
            for(int i = 0; i < 10; i++){
                alloc.insert(PTBR + i);
                memory[PTBR + i][0] = '*';
                memory[PTBR + i][1] = '*';
                memory[PTBR + i][2] = '*';
                memory[PTBR + i][3] = '*';
            }

            int firstEntry = rand() % 30;

            while(alloc.find(firstEntry*10) != alloc.end()){
                firstEntry = rand() % 30;
            }   
            string entry = to_string(firstEntry);

            if(entry.size() == 1){
                memory[PTBR][2] = '0';
                memory[PTBR][3] = entry[1];
            }
            else{
                memory[PTBR][2] = entry[0];
                memory[PTBR][3] = entry[1];
            }

            prog_location = firstEntry*10;
            alloc.insert(prog_location);

            getline(inputfile, buffer);

            int memoryaddr = prog_location;
            int byteswritten = 0;
            int wordoffset = 0;
            //load code in memory
            while(buffer.substr(0,4) != "$DTA"){

                for(int i = 0; i < buffer.size(); i++){
                    alloc.insert(memoryaddr);
                    if(buffer[i] == 'H'){
                        memory[memoryaddr][wordoffset] = buffer[i];
                        memoryaddr++;
                    }
                    else{
                        memory[memoryaddr][wordoffset] = buffer[i];
                        byteswritten++;   
                    }

                    if(byteswritten % 4 == 0){
                        wordoffset = 0;
                        memoryaddr++;
                        byteswritten = 0;
                    }
                    else{
                        wordoffset++;
                    }
                }
                getline(inputfile, buffer);
            }
            //program loaded in memory

            buffer.clear();
            startExecution();
            endExecution(jobs[cnt].TTC, jobs[cnt].TLC);
            getline(inputfile, buffer);
        }
    }
    inputfile.close();
}

void OS :: endExecution(int TTC, int TLC){
    
    outputfile.open("output.txt", ios::app);

    if(TTC > TTL){
        outputfile << "Time limit exceeded" << endl;
    }
    if(TLC > TLL){
        outputfile << "Line limit exceeded" << endl;
    }

    if(EM == 0){
        outputfile << "Program terminated normally!" << endl;
        outputfile << "\nSI = " << SI << "  TI =" << TI << "  PI =" << PI << endl;
        outputfile << "TTC = " << TTC << "  TLC =" << TLC << endl;
        outputfile << "------------------------------------------------------------------" << endl
            << endl;
        outputfile.close();
        return;
    }
    else if(EM == 1){
        outputfile << "Out of data error...abnormal termination!" << endl;
        outputfile << "\nSI = " << SI << "  TI =" << TI << "  PI =" << PI << endl;
        outputfile << "TTC = " << TTC << "  TLC =" << TLC << endl;
        outputfile << "------------------------------------------------------------------" << endl
            << endl;
        outputfile.close();
        return;
    }
    else if(EM == 4){
        outputfile << "Opcode error...abnormal termination!" << endl;
        outputfile << "\nSI = " << SI << "  TI =" << TI << "  PI =" << PI << endl;
        outputfile << "TTC = " << TTC << "  TLC =" << TLC << endl;
        outputfile << "------------------------------------------------------------------" << endl
            << endl;
        outputfile.close();
        return;
    }
    else if(EM == 5){
        outputfile << "Operand Error...abnormal termination!" << endl;
        outputfile << "\nSI = " << SI << "  TI =" << TI << "  PI =" << PI << endl;
        outputfile << "TTC = " << TTC << "  TLC =" << TLC << endl;
        outputfile << "------------------------------------------------------------------" << endl
            << endl;
        outputfile.close();
        return;
    }
    else if(EM == 6){
        outputfile << "Invalid Page fault...abnormal termination!" << endl;
        outputfile << "\nSI = " << SI << "  TI =" << TI << "  PI =" << PI << endl;
        outputfile << "TTC = " << TTC << "  TLC =" << TLC << endl;
        outputfile << "------------------------------------------------------------------" << endl
            << endl;
        outputfile.close();
        return;
    }
    else{
        return;
    }
    
};

int OS :: AddressMap(int VA, string opcode){
    
    int RA;
    int PTE = PTBR + (VA / 10);       //page table entry for data

    if(memory[PTE][2] == '*' && memory[PTE][3] == '*'){         //Page fault occured
        
        if(opcode == "PD"){
            PI = 3;
            return -1;
        }

        int data_location = rand() % 30;
        if(alloc.find(data_location*10) == alloc.end()){
            alloc.insert(data_location*10);
        }
        else{
            while(alloc.find(data_location*10) != alloc.end()){
                data_location = rand() % 30;
            }
            alloc.insert(data_location*10);
        }

        string entry = to_string(data_location);
        if(entry.size() == 1){
            memory[PTE][2] = '0';
            memory[PTE][3] = entry[0];
        }
        else{
            memory[PTE][2] = entry[0];
            memory[PTE][3] = entry[1];
        }

        RA = data_location * 10 + VA % 10;
    }
    else{
        string translator = "";
        translator.push_back(memory[PTE][2]);
        translator.push_back(memory[PTE][3]);

        int data_loc = stoi(translator);
        RA = data_loc*10 + VA%10;
    }
    return RA;
}

int main(){
    OS os;
    os.load();
}
$AMJ000500150003
GS20PD20GD30PD30GD40PD40H
$DTA
EDI Group
SWARAJ AADITYA
SRUJAN ABHEERAV
$END0005
$AMJ000300150003
GD20GD30GD40GD50LR20CR30BT09PD50HPD40
H
$DTA
VIT
VIIT
IS SAME
NOT SAME
$END0003
$AMJ000100040000
GD10PD10H
$DTA
Hello World
$END0001
$AMJ020200160005
GD20PD20LR20SR30SR31PD30SR40SR41SR42PD40
SR50SR51PD50SR60PD60H
$DTA
$   
$END0202
$AMJ020300160005
GD999PD20LR20SR30SR31PD30SR40SR41SR42PD40
SR50SR51PD50SR60PD60H
$DTA
@
$END0203
$AMJ020500250005
GD20PD20LR20SR30SR31PD30SR40SR41SR42PD40
SR50SR51PD50SR60PD60H
$DTA
$END0205
