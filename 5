Disk Scheduling Simple

1) FCFS

#include <stdio.h>
#include <stdlib.h>

int main()
{
    int queue[100], q_size, head, seek = 0, diff;
    float avg;

    printf("%s\n", "***FCFS Disk Scheduling Algorithm***");

    printf("%s\n", "Enter the size of the queue");
    scanf("%d", &q_size);

    printf("%s\n", "Enter queue elements");
    for (int i = 1; i <= q_size; i++)
    {
        scanf("%d", &queue[i]);
    }

    printf("%s\n", "Enter initial head position");
    scanf("%d", &head);

    queue[0] = head;

    for (int j = 0; j <= q_size - 1; j++)
    {
        diff = abs(queue[j] - queue[j + 1]);
        seek += diff;
        printf("Move from %d to %d with Seek %d\n", queue[j], queue[j + 1], diff);
    }

    printf("\nTotal seek time is %d\t", seek);
    avg = seek / (float)q_size;
    printf("\nAverage seek time is %f\t", avg);

    return 0;
}

2) SSTF

/*
  SSTF Disk Scheduling Algorithm
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main()
{
    int queue[100], queue2[100], q_size, head, seek = 0, temp;
    float avg;

    printf("%s\n", "-----SSTF Disk Scheduling Algorithm-----");

    printf("%s\n", "Enter the size of the queue");
    scanf("%d", &q_size);

    printf("%s\n", "Enter queue elements");
    for (int i = 0; i < q_size; i++)
    {
        scanf("%d", &queue[i]);
    }

    printf("%s\n", "Enter initial head position");
    scanf("%d", &head);

    // get distance from head of elems in queue
    for (int i = 0; i < q_size; i++)
    {
        queue2[i] = abs(head - queue[i]);
    }

    // swap elems based on their distance from each other
    for (int i = 0; i < q_size; i++)
    {
        for (int j = i + 1; j < q_size; j++)
        {

            if (queue2[i] > queue2[j])
            {
                temp = queue2[i];
                queue2[i] = queue[j];
                queue2[j] = temp;

                temp = queue[i];
                queue[i] = queue[j];
                queue[j] = temp;
            }
        }
    }

    for (int i = 1; i < q_size; i++)
    {
        seek = seek + abs(head - queue[i]);
        head = queue[i];
    }

    printf("\nTotal seek time is %d\t", seek);
    avg = seek / (float)q_size;
    printf("\nAverage seek time is %f\t", avg);

    return 0;
}

3) SCAN 

#include <stdio.h>
#include <stdlib.h>

#define LOW 0
#define HIGH 199

int main()
{
    int queue[20];
    int head, max, q_size, temp, sum;
    int dloc; // location of disk (head) arr

    printf("%s\t", "Input no of disk locations");
    scanf("%d", &q_size);

    printf("%s\t", "Enter head position");
    scanf("%d", &head);

    printf("%s\n", "Input elements into disk queue");
    for (int i = 0; i < q_size; i++)
    {
        scanf("%d", &queue[i]);
    }

    queue[q_size] = head; // add RW head into queue
    q_size++;

    // sort the array
    for (int i = 0; i < q_size; i++)
    {
        for (int j = i; j < q_size; j++)
        {
            if (queue[i] > queue[j])
            {
                temp = queue[i];
                queue[i] = queue[j];
                queue[j] = temp;
            }
        }
    }

    max = queue[q_size - 1];

    // locate head in the queue
    for (int i = 0; i < q_size; i++)
    {
        if (head == queue[i])
        {
            dloc = i;
            break;
        }
    }

    if (abs(head - LOW) <= abs(head - HIGH))
    {

        for (int j = dloc; j >= 0; j--)
        {
            printf("%d --> ", queue[j]);
        }
        for (int j = dloc + 1; j < q_size; j++)
        {
            printf("%d --> ", queue[j]);
        }
    }
    else
    {

        for (int j = dloc + 1; j < q_size; j++)
        {
            printf("%d --> ", queue[j]);
        }
        for (int j = dloc; j >= 0; j--)
        {
            printf("%d --> ", queue[j]);
        }
    }

    sum = head + max;
    printf("\nmovement of total cylinders %d", sum);

    return 0;
}

PAGE REPLACEMENT

1) FIFO
2.	#include <stdio.h>
3.	void main()
4.	{
5.	    int i, j, k, f, pf = 0, count = 0, rs[25], frame[10], n;
6.	    printf("\n Enter the length of reference string -- ");
7.	    scanf("%d", &n);
8.	    printf("\n Enter the reference string -- ");
9.	    for (i = 0; i < n; i++)
10.	        scanf("%d", &rs[i]);
11.	
12.	    printf("\n Enter no. of frames -- ");
13.	    scanf("%d", &f);
14.	
15.	    for (i = 0; i < f; i++)
16.	        frame[i] = -1;
17.	
18.	    printf("\n The Page Replacement Process is -- \n");
19.	    for (i = 0; i < n; i++)
20.	    {
21.	        printf("%d\t", rs[i]);
22.	        for (k = 0; k < f; k++)
23.	        {
24.	            if (frame[k] == rs[i])
25.	                break;
26.	        }
27.	        if (k == f)
28.	        {
29.	            frame[count++] = rs[i];
30.	            pf++;
31.	        }
32.	        for (j = 0; j < f; j++)
33.	            printf("\t%d", frame[j]);
34.	
35.	        printf("\tPF No. %d", pf);
36.	
37.	        printf("\n");
38.	        if (count == f)
39.	            count = 0;
40.	    }
41.	    printf("\n The number of Page Faults using FIFO are %d", pf);
42.	}



2) LRU
#include <stdio.h>

void main()
{
    int i, j, f, pf = 0, rs[25], frame[10], n, age[10];
    printf("\n Enter the length of reference string -- ");
    scanf("%d", &n);
    printf("\n Enter the reference string -- ");
    for (i = 0; i < n; i++)
    {
        scanf("%d", &rs[i]);
    }
    printf("\n Enter no. of frames -- ");
    scanf("%d", &f);

    for (i = 0; i < f; i++)
    {
        frame[i] = -1;
        age[i] = 0;
    }

    printf("\n The Page Replacement Process is -- \n");
    for (i = 0; i < n; i++)
    {
        printf("%d\t", rs[i]);
        int found = 0;
        for (j = 0; j < f; j++)
        {
            if (frame[j] == rs[i])
            {
                age[j] = 0;
                found = 1; // no page fault
                break;
            }
        }
        // Inside the loop where you check for page fault
        if (!found) // page fault
        {
            int empty_frame_index = -1; // Initialize to -1, indicating no empty frame found
            for (j = 0; j < f; j++)
            {
                if (frame[j] == -1)
                {
                    empty_frame_index = j;
                    break; // Found an empty frame, exit the loop
                }
            }

            if (empty_frame_index != -1)
            {
                // If an empty frame is available, load the page into it
                frame[empty_frame_index] = rs[i];
                age[empty_frame_index] = 0;
            }
            else
            {
                // If no empty frame is available, perform LRU replacement as before
                int max_age = age[0];
                int max_age_index = 0;
                for (j = 1; j < f; j++)
                {
                    if (age[j] > max_age)
                    {
                        max_age = age[j];
                        max_age_index = j;
                    }
                }
                frame[max_age_index] = rs[i];
                age[max_age_index] = 0;
            }

            pf++; // Increment page fault count
        }

        // If there was a page fault, print the page fault number

        for (j = 0; j < f; j++)
        {
            printf("\t%d", frame[j]);
            age[j]++;
        }

        if (!found)
        {
            printf("\t\t\tPF No. %d", pf);
        }

        printf("\n");
    }
    printf("\n The number of Page Faults using LRU are %d", pf);
}



3) Optimal

#include <stdio.h>

int main()
{
    int i, j, k, n, f, max, pf = 0;
    int rs[25], frame[10], next[25];

    printf("\nEnter the length of reference string -- ");
    scanf("%d", &n);

    printf("\nEnter the reference string -- ");
    for (i = 0; i < n; i++)
    {
        scanf("%d", &rs[i]);
    }

    printf("\nEnter no. of frames -- ");
    scanf("%d", &f);

    for (i = 0; i < f; i++)
    {
        frame[i] = -1;
    }

    for (i = 0; i < n; i++)
    {
        int flag = 0;

        // Check if page is already in frame
        for (j = 0; j < f; j++)
        {
            if (frame[j] == rs[i])
            {
                flag = 1;
                break;
            }
        }

        // If not in frame, find the page with the furthest future reference
        if (flag == 0)
        {
            max = -1;
            for (j = 0; j < f; j++)
            {
                int found = 0;
                for (k = i + 1; k < n; k++)
                {
                    if (frame[j] == rs[k])
                    {
                        found = 1;
                        break;
                    }
                }
                if (found == 0)
                {
                    next[j] = n;
                }
                else
                {
                    next[j] = k;
                }
                if (next[j] > max)
                {
                    max = next[j];
                    flag = j;
                }
            }
            frame[flag] = rs[i];
            pf++;
        }

        // Print current page and frame
        printf("%d\t", rs[i]);
        for (j = 0; j < f; j++)
        {
            printf("%d\t", frame[j]);
        }

        // If there was a page fault, print the page fault number
        if (flag != 0)
        {
            printf("PF No. %d", pf);
        }
        printf("\n");
    }

    printf("\nThe number of page faults using Optimal algorithm are %d", pf);

    return 0;
}


