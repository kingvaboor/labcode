Disk Scheduling 

1) FIFO

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int fcfs_disk_scheduling(const vector<int>& requests, int initial_position) {
    int total_seek_time = 0;
    int current_position = initial_position;

    for (int request : requests) {
        total_seek_time += abs(request - current_position);
        current_position = request;
    }
    return total_seek_time;
}

int main() {

    int n;
    cout << "Enter the number of request positions for a process: ";
    cin >> n;

     vector<int> requests(n);
    for(int i = 0; i < n; i++){
        int ele;
        cin >> ele;
        requests[i] = ele;
    }
    int initial_position = 53;
    cout << "Enter initial position of head: ";
    cin >> initial_position;
    
    int seek_time = fcfs_disk_scheduling(requests, initial_position);
    cout << "Total seek time using FCFS: " << seek_time << endl;

    return 0;
}

2) SSTF


#include <iostream>
#include <vector>
#include <cmath>
#include <limits>
#include <algorithm>

using namespace std;

int find_closest_request(const vector<int>& requests, int current_position) {
    int min_distance = numeric_limits<int>::max();
    int closest_request = -1;

    for (int request : requests) {
        int seek_distance = abs(request - current_position);
        if (seek_distance < min_distance) {
            min_distance = seek_distance;
            closest_request = request;
        }
    }

    return closest_request;
}

int sstf_disk_scheduling(vector<int>& requests, int initial_position) {
    int total_seek_time = 0;
    int current_position = initial_position;

    while (!requests.empty()) {
        int closest_request = find_closest_request(requests, current_position);
        total_seek_time = abs(closest_request - current_position);
        current_position = closest_request;

        // Remove the serviced request from the list
        vector<int>::iterator it = find(requests.begin(), requests.end(), closest_request);
        if (it != requests.end()) {
            requests.erase(it);
        }
    }
    return total_seek_time;
}

int main() {
    
    int n;
    cout << "Enter the number of request positions for a process: ";
    cin >> n;

     vector<int> requests(n);
    for(int i = 0; i < n; i++){
        int ele;
        cin >> ele;
        requests[i] = ele;
    }
    
    int initial_position = 53;
    cout << "Enter initial position of head: ";
    cin >> initial_position;

    int seek_time = sstf_disk_scheduling(requests, initial_position);
    cout << "Total seek time using SSTF: " << seek_time << endl;

    return 0;
}

3) SCAN

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int scan_disk_scheduling(const vector<int>& requests, int initial_position, int max_track) {
    vector<int> left_requests, right_requests;
    int total_seek_time = 0;

    for (int request : requests) {
        if (request < initial_position) {
            left_requests.push_back(request);
        } else {
            right_requests.push_back(request);
        }
    }

    sort(left_requests.begin(), left_requests.end(), greater<int>());
    sort(right_requests.begin(), right_requests.end());

    for (const auto& request : {right_requests, left_requests}) {
        for (int r : request) {
            total_seek_time += abs(initial_position - r);
            initial_position = r;
        }
    }

    return total_seek_time;
}

int main() {
    
    int n {0};
    int max_track {199};
    int initial_position {53};

    cout << "Enter the number of request positions for a process: ";
    cin >> n;

     vector<int> requests(n);
    for(int i = 0; i < n; i++){
        int ele;
        cin >> ele;
        requests[i] = ele;
    }

    cout << "Enter initial position of head: ";
    cin >> initial_position;
    
    cout << "Enter the max track: ";
    cin >> max_track;

    int seek_time = scan_disk_scheduling(requests, initial_position, max_track);
    cout << "Total seek time using SCAN (Elevator): " << seek_time << endl;

    return 0;
}

PAGE REPLACEMENT

1) FIFO
#include<iostream>
#include<vector>
#include<queue>
#include<unordered_set>
using namespace std;

void FIFO(vector<int> &references, int frames){
    queue<int> fifoQ;
    unordered_set<int> Frames(frames);
    int pageFaults {0};

    for(int page: references){
        if(Frames.find(page) == Frames.end()){
            if(Frames.size() == frames){
                int oldestpage = fifoQ.front();
                fifoQ.pop();
                Frames.erase(oldestpage);
                cout << "Page " << oldestpage << " was removed from memory.\n";
            }
            Frames.insert(page);
            fifoQ.push(page);
            pageFaults++;
            cout << "Page " << page << " was inserted in memory.\n";
        }
        else{
            cout << "Page " << page << " was already present in a frame." <<endl;
        }
    }
    cout << "Total page Faults: " << pageFaults << ".";
}

int main(){
    int frames;
    cout << "Enter number of page frames: ";
    cin >> frames;
    
    int n;
    cout << "Enter number of page references: ";
    cin >> n;

    vector<int> references(n);
    cout << "Enter references: ";
    for(int i = 0; i < n; i++){
        cin >> references[i];
    }
    FIFO(references, frames);
}

2) LRU
#include <iostream>
#include <vector>
#include <list>
#include <unordered_map>
using namespace std;

void lruPageReplacement(vector<int>& ref_string, int& capacity){
    int pageFaults {0};                                  // Counter for page faults
    list<int> pageList;                                 // learn about the lru page loaded in frames
    unordered_map<int, list<int>::iterator> pageTable;  // reps pages laoded

    for(int page : ref_string){
        if(pageTable.count(page) > 0){
            pageList.splice(pageList.begin(), pageList, pageTable[page]);
        }
        else{
            if(pageList.size() >= capacity){
                int lrupage = pageList.back();
                pageList.pop_back();
                pageTable.erase(lrupage);
                cout << "page " << lrupage << " was removed from memory." << endl;
            }
            pageList.push_front(page);
            pageTable[page] = pageList.begin();
            cout << "page " << page << " was added to memory" << endl;
            pageFaults++;
        }
    }

    cout << "Total number of page faults are: " << pageFaults << endl;
}

int main(){
    int num_frames, page_refs;
    cout << "Enter number of frames: ";
    cin >> num_frames;
    cout << "Enter number of references: ";
    cin >> page_refs;
    cout << "Enter reference string: ";

    vector<int> ref_string(page_refs);

    for(int i = 0; i < page_refs; i++){
        cin >> ref_string[i];
    }
    
    lruPageReplacement(ref_string, num_frames);
    return 0;
}

3) Optimal

#include<iostream>
#include<vector>
#include<map>
#include<algorithm>
using namespace std;

int findOptimal(vector<int> &references, map<int, int> &pageTable, int startIndex){
    int optimal = -1, farthest = -1;

    for(auto it = pageTable.end(); it != pageTable.begin(); it--){
        int page = it->first;
        int index = it->second;
        
        auto lastOccurence = find(references.rbegin(), references.rend() - startIndex, page);
        if(lastOccurence == references.rend() - startIndex){
            return page;
        }
        int farthestIndex = references.rend() - 1 - lastOccurence;
        if(farthestIndex > farthest){
            farthest = farthestIndex;
            optimal = page;
        }
    }
    return optimal;
}

void optimal(vector<int> &references, int num_frames){
    int pageFaults {0};
    map<int, int> pageTable;

    for(int i = 0; i < references.size(); i++){
        if(pageTable.find(references[i]) == pageTable.end()){
            if(pageTable.size() == num_frames){
                int optimal = findOptimal(references, pageTable, i);
                pageTable.erase(optimal);
                cout << "page " << optimal << " removed\n";
            }
            pageTable[references[i]] = i;
            pageFaults++;
            cout << "page " << references[i] << " added\n";
        }
    }
    cout << "Total page Faults: "<< pageFaults;
}

int main() {
    int n; 
    cout << "Number of page references: ";
    cin >> n;

    cout << "Enter page references: ";
    vector<int> references(n);
    for (int i = 0; i < n; i++) {
        cin >> references[i];
    }

    int frames;
    cout << "Enter number of frames: ";
    cin >> frames;
    optimal(references, frames);
}
